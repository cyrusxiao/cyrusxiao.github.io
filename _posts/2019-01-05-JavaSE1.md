---
layout: article
title: JavaSE学习笔记（第一部分）
tags: JavaSE Java基础
article_header:
  type: cover
  image:
    src: /images/JavaSE1.jpg
key: JavaSE1
---

# 一、Hello world

**jre：** java runtime environment 包括java.exe（虚拟机）和java基础类库。 <br> 
**jdk：** java development kits 包括javac.exe（编译器）和jre。 <br>
*创建java源文件（\*.java）:* <br>

```
package hello; //包名
public class Hello{ //一个包只能有一个public类
    public static void main(String[] args){ //一个类中只能有一个main方法
        System.out.println("Hello, world!");
    }
}
```

**注释：** 对代码进行解释说明，不会被编译进字节码文件： <br>
//注释内容（单行文本注释） <br>
/\*注释内容\*/（多行文本注释） <br>
**package：** 包，对java源文件进行分类管理，包的声明必须是java源文件的第一个语句。 <br>
**import：** 引用其它包中的类，所有java源文件默认有java.lang.* <br>
一个类完整的名字是：包名.类名 <br>

# 二、java语法

## 1.标识符
java中所有的名字；作用是同类之间相互区分，方便调用；由字母、数字、下划线、$组成，区分大小写，不能以数字开头，不能是java关键字。 <br>

## 2.命名规范
编程养成的好习惯，尽量增强可读性；类名首字母大写；变量名除了第一个单词其余单词首字母大写；被finally修饰的变量名每个字母都大写。 <br>

## 3.关键字
被java赋予特殊含义的单词或字符。 <br>

## 4.基本数据类型

| 关键字             | 类型              | 字节               | 范围              | 默认值             |
| ---               | ---               | ---               | ---               | ---               |
| byte              | 字节型             | 1                 | \[-128, 127\]     | 0                 |
| short             | 短整型             | 2                 | \[-32768, 32767\] | 0                 |
| short             | 短整型             | 2                 | \[-32768, 32767\] | 0                 |
| long              | 长整型             | 8                 |                   | 0L                |
| float             | 单精度浮点型        | 4                 |                   | 0.0F              |
| double            | 双精度浮点型        | 8                 |                   | 0.0               |
| char              | 字符型             | 2                 |                   | '\u0000'          |
| boolean           | 布尔型             | 1                 | true/false        | false             |

* 整数类型不注明时默认int
* 浮点类型不注明时默认double
* 1byte（字节）=8bit（比特，0/1）
<br> 

## 5.引用数据类型
多个基本数据有机组合的整体，也称之位对象。 <br> 

## 6.常量与变量
常量：程序中值不能变化的量，如1、1.0f、’F’。 <br>
变量：程序中值可以变化的量。 <br>
java中处理变量： <br>
①先定义变量：数据类型  变量名; <br>
②给变量赋值：变量名=常量值; <br>
③使用变量 <br>
注意：同一类中，变量只能定义一次；定义相同类型的多个变量语句可以合并，如：short s1=1, s2=2, s3=3; <br>
**数据类型转换：** <br>
数据类型精度表：byte < short < (char) int < long < float < double  <br>
①自动类型转换情况一：高精度变量=低精度值; <br>
如`long lon=1;  //1先由默认的int类型转换为long类型，再赋值给lon。` <br>
②自动类型转换情况二：byte、short、char类型的变量=int类型常量值; <br>
如`byte b=1; //int类型1前面有3个字节都是无效的0，计算机自动去除1前面3个字节转换成byte类型的1赋值给b。` <br>
*计算机先检测左边的变量能否装下右边的数值，不能装下就报错，能装下就先转换数据类型再赋值。* <br>
③强制类型转换：低精度变量=(低精度变量类型)高精度值; <br>
如`byte b1=134; //强制将int类型的134最后一个字节赋值给b1。` <br>

## 7.运算
* 运算的结果类型取决于精度最高的数据。
* byte、short、char不能直接参与运算，必须先自动转换为int。
* 浮点类型数据运算时有误差。
* 字符类型数据参与运算时，先自动转换为int。 
* 字符与整数之间转换的桥梁：编码集。
* ASCⅡ：美国字符标准转换码表，所有编码集都兼容此表。
* ‘0’: 48		‘A’: 65		‘a’: 97
* 支持中文的编码表：gbk、gb2312
* 万国表：utf-8
* 无中文码表：iso 8859-1 <br>

**运算符：**   <br>

① **算术运算符：**  +、-、\* 、/、%（求余、取模）、++（自增）、--（自减） <br>  
* 获取一个多位数前面的数字用除，后面的数字用余。
* a++; 等价于a=(a的数据类型)(a+1); ，等价于++a; 。
* 自增自减参与混合运算：自增自减在前，先自增自减再运算；自增自减在后，先运算再自增自减。
* 字符串连接符：与字符串相邻的+就是字符串连接符，任何数据与字符串相连都形成一个新的字符串。<br>

② **赋值运算符：**  =、+=、-=、\*=、/=、%=   <br>

* a+=b; 完全等价于a=(a的数据类型)(a+b); 其它以此类推。<br>

③ **比较运算符：**  >、<、>=、<=、==（恒等于）、!=（不等于） <br>

* 运算结果是true/false。 <br>

④ **逻辑运算符：**  &&（双与）、\|\|（双或）、&（单与）、\|（单或）、^（异或）、!（非） <br>

*  **单和双的区别：**  单与和单或还可以作为位运算符；双与和双或有短路功能，双与前面的逻辑结果为false时不再进行后面的逻辑表达式运算，直接出结果为false，双或前面的逻辑结果为true时不再进行后面的逻辑表达式运算直接出结果为true。
*  **异或：**  前后逻辑表达式结果相同时为false，相异时为true。还可以作为位运算符。<br>

⑤ **位运算符（操作二进制数据）：** &、\|、^、\<<、\>>  <br>

```
14&5 = 4
-----------------
|  1110    14   |
|  0101    5    |
|---------------|
|  0100    4    |
-----------------

5<<3 = 40
--------------------
|  101    5        |
|--左移三位后-------|
|  101 000    4    |
--------------------

```

6<<1 = 6\*2^1 = 12  <br>
6>>1 = 6/2^1 = 3  <br>

⑥ **三元运算符：**  条件表达式a?值1: 值2	（表达式a为true取值1，否则取值2）<br>

## 8.流程控制
① **顺序结构：** （默认）从左到右，从上到下。 <br>
② **if选择结构：** 根据条件判断是否执行相应代码。 <br>
* 单分支：`if(条件表达式){语句块; }`
* 双分支：`if(条件表达式){语句块; }else{语句块; }`
* 多分支：`if(条件表达式){语句块; }else if(条件表达式){语句块; }`  <br>

③ **switch选择结构：**  <br> 

```
/**
* 1.表达式的值类型仅限于byte、short、char、int、枚举(jdk1.5)、String(jdk1.7)；
* 2.case值不能重复，为final型的常亮、byte、short、 char、int、‘表达式或者变量’；
* 3.switch语句和某个case后的常量值相等，就执行该case后面的语句，直到碰到break结束，
*   如果没有相等的，就执行default后面的语句，default并不是必须的。
*/
switch(表达式){
    case 值1:
        语句块1;
        break;
    case 值2:
        语句块2;
        break;
    ...
    default:
        语句块n;
        break;    
} 
``` 

④ **循环结构：** 需要具备循环的条件、迭代语句（如a++）、循环体 <br>
**先判断，再运行：** `while(条件表达式){循环体和迭代语句}`  <br>
**先运行，再判断：** `do{循环体和迭代语句}while(条件表达式);`  <br>
**for循环：** `for(初始化语句; 条件表达式; 迭代语句){循环体}`  <br>
* 初始化语句可以省略，而写在for前面；条件表达式可以省略，默认为true；迭代语句可以省略，而写在循环体中。
变量的作用域取决于它外面的大括号。<br> 

⑤ **跳转结构：**  <br>
break跳出当前循环，continue不再执行当前语句后面的语句。 <br>
break\[标签\]和continue\[标签\]: <br>

```
/**
* 跳到外循环结束循环
*/
int sun=0;
out:for(int i=0; i<10; i++){
    for(int j=0; j<10; j++){
        sum+=i;
        if(j==5){
            break out;
        }
    }
}
--------------------------------
/**
* 跳到外循环继续执行下次循环
*/
int sun=0;
out:for(int i=0; i<10; i++){
    for(int j=0; j<10; j++){
        sum+=i;
        if(j==5){
            continue out;
        }
    }
}
```

return\[返回参数\]; 跳出当前方法体。 <br>

## 9.数组
概念：装相同类型，指定数目数据（元素）的容器。 <br>
特点：数据个数固定，数据类型相同（基本数据类型、引用数据类型）。 <br>
创建数组对象： <br>
①元素类型[] 数组名=new 元素类型\[元素个数\];  <br>
②元素类型[] 数组名=new 元素类型[]{元素0, 元素1, 元素2, …};  <br>
③元素类型[] 数组名={元素0, 元素1, 元素2, …};  <br>
**注意：**  <br>
* 数组中元素有默认初始值；
* 数组会自动给元素分配下标，从0到length-1，调用数组中元素用：数组名\[下标\]；
* 数组对象的字符串表示形式：对象类型@16进制内存地址；
* 格式③不允许定义数组名和创建数组对象分开写；
* 三种创建对象的格式后面都有分号； <br>

**数组排序：**  <br>


**多维数组：**  <br>
①元素类型[][] 数组名=new元素类型\[一维数组个数m\]\[一维数组的元素个数n\];  <br>
②元素类型[][] 数组名=new元素类型[][]\{\{a1, a2, …\}, \{b1, b2, …\}, …\};  <br>
③元素类型[][] 数组名= \{\{a1, a2, …\}, \{b1, b2, …\}, …\};  <br>

## 10.方法（函数）
```
/**
* 修饰符：修饰方法，如果方法想被主方法直接调用，必须有static；
* 参数列表：定义变量，用于接收方法需要的原始数据；
* 返回值类型为void时，return;可以省略。
*/
修饰符 返回值类型 方法名(参数列表){
    方法体;
    return 返回值;
}
```

## 11.面向对象
面向过程：将事情分为多个步骤逐个去解决。（如C语言） <br>
面向对象：指挥能解决事情的对象去解决问题。 <br>
**面向对象的步骤：**  <br>
①创建一个类描述一类事物； <br>
②通过类创建对象； <br>
③给对象的属性赋值； <br>
④调用对象的方法解决问题。 <br>
面向对象的优点：把复杂问题简单化；程序员由执行者转换为指挥者。 <br>
**构造方法：** 创建对象时调用的方法。 <br>
**成员方法：** 类中定义的方法。 <br>
**成员变量：** 类中定义的变量。 <br>
**局部变量：** 在方法中定义的变量。 <br>
一个类中定义了哪些成员变量决定了此类创建的对象具有哪些属性。 <br>
**成员变量与局部变量的区别：**  <br>
* 成员变量作用于整个类，局部变量作用于当前方法；
* 成员变量有默认初始值（引用数据类型的初始值为null），局部变量没有默认初始值；
* 成员变量可以有多种修饰符，局部变量只能有final修饰符。
* 构造方法与普通方法的区别：
* 构造方法的名字必须是类名；
* 构造方法没有返回值，且不用void表示没有返回值；
* 构造方法只能被new调用，普通方法只能被对象调用；
* 构造方法有默认的无参数构造方法，没有默认的普通方法；
* 构造方法用于创建对象，普通方法表示此类创建的对象具有某一功能。<br>
 
**方法重载（overload）：**  <br>
一个类中，几个方法的方法名相同，参数列表不同的现象。（参数列表不同是指参数类型不同、参数个数不同或参数顺序不同，方法重载对方法的修饰符、返回值类型没有要求，一般情况下只有构造方法使用方法重载） <br>
**方法的参数传递：**  <br>
基本数据类型作为参数传递的是常量值；引用数据类型作为参数传递的是引用数据对象的内存地址。 <br>
**给对象的属性赋值：**  <br>
①对象名.属性名=值; （只能更改当前对象的属性值）  <br>
②对象名.方法名(值); （只能更改当前对象的属性值）  <br>
③创建类时直接给成员变量赋值 （对象一创建就有相应的属性值）  <br>
④通过构造方法给成员变量赋值 （根据此构造方法创建的对象具有指定的属性值）  <br>
**关键字this：**  <br>
①当成员变量和局部变量重名时，可以在当前方法中用this.变量名指向成员变量。 <br>
②在一个构造方法中想要调用另一个构造方式时（复用其方法体），用this(参数列表)来调用指定的构造方法。 <br>
注意：this(参数列表)必须是当前方法的第一个语句。 <br>

## 12.修饰符

### static修饰符
* **static修饰成员变量：** static修饰的成员变量称之为共享数据，此类的一个对象的static属性更改，此类其他对象的对应属性也随之更改。 <br>
* **static修饰普通方法：** static修饰的普通方法不但可以被对象调用，也可以被类直接调用（类名.方法名(参数值)）；static修饰的方法只能调用静态方法，不能调用非静态方法。 <br>
* 被static修饰的成员称为静态成员、类成员，属于类。没有被static修饰的成员称为实例成员，属于对象。 <br>
* `static{}`称为静态代码块，一般用于给静态成员变量赋初始值。 <br>
* 没有使用非静态成员的普通方法尽量定义为静态方法；但需要类的所有对象对应属性保持一致时，将该成员变量定义为静态的。<br>

**注意：**  <br>

* 静态成员不可以用this；
* 静态方法不允许是抽象的；
* 静态代码块当创建第一个对象时运行。
* 范围修饰符private：
* 被private修饰的成员称为私有成员，只有本类可以直接访问；
* 为了让不可信任的类或对象访问，需要提供公共的get和set方法：`public 返回数据类型 getXxx(){}` 和 `public void setXxx(){}`  <br>

### 范围修饰符

| 范围修饰符 | 作用范围 |
| --- | --- |
| public | 当前项目 |
| protected | 本包和其他包的子类 |
| 默认的 | 本包 |
| private | 本类 |

### final修饰符
**final修饰变量，** 在对象创建前必须有值（创建类时直接赋值、通过构造方法给final修饰的属性赋值），且只能赋值一次；final修饰引用类型变量，应用类型变量对象不能更改。 <br>
**final修饰方法，** 该方法为最终方法，不能被重写。 <br>
**final修饰类，** 该类为最终类，不能被继承。 <br>

## 13.继承
从现有的类（父类、超类、根类）派生出来子类的现象。 <br>
**关键字：** extends  <br>
**格式：** class 子类名 extends 父类名{}  <br>
**特点：**  <br>
①不能继承构造方法； <br>
②子类可以定义特有成员； <br>
③子类可以重新定义父类的成员； <br>
④子类继承父类的成员变量要求变量名一样；子类继承父类的方法要求方法声明完全一致，除了范围修饰符可以扩大； <br>
⑤只支持单继承，一个子类只能有一个直接父类； <br>
⑥所有类直接或间接继承Object类； <br>
⑦子类继承父类的私有成员不能直接使用； <br>
**重写（override）：** 子类重新定义父类的成员方法。要求方法声明除了范围修饰符可以扩大外其余的完全一致。 <br>
子类重写父类的方法实质是将父类被重写的方法隐藏了。 <br>
**关键字super：**  <br>
①所有子类构造方法中第一句默认调用了父类的无参构造方法super(); 创建子类对象时，必须通过调用父类的构造方法将父类中定义的成员加载进子类对象内存中； <br>
②子类中通过super.调用父类成员：子类调用子类重新定义父类的成员时默认调用的是子类重新定义的成员，通过super.调用父类中被隐藏的成员；子类调用父类的成员前面默认有super. 。 <br>

## 14.多态
**多态概念：** 让父类引用指向子类对象（也叫向上转型）。 <br>
**多态特点：** 除了重写的方法，多态对象和父类对象完全一样。 <br>
**优点：** 方法复用性增强，提高了程序的扩展性。 <br>
**使用场景：** 定义方法参数列表时、方法返回值类型时、类成员变量时，定义为父类类型，这样就可以传递、返回、赋值任意子类类型的对象。 <br>
**多态对象向下转型：**  <br>
格式：`子类类型 之类名=(子类类型)多态对象名`  <br>
比较运算符instanceof 用来判断参数类型。 <br>
**多态内存图：**  <br>

![多态内存图](/images/JavaSE_duotai.png)

## 15.abstract
抽象修饰符，修饰类和方法。 <br>
**特点：**  <br>
①抽象方法必须定义在抽象类里； <br>
②抽象方法不能有方法体{}； <br>
③抽象类不能创建对象，但可以定义引用，指向子类； <br>
④抽象类有构造方法； <br>
⑤抽象类的子类除非重写父类所有的抽象方法，否则仍然是抽象类。 <br>

## 16.接口
当一个抽象类中所有方法都是抽象类时，这个类称之为接口。 <br>
**关键字：** interface  <br>
**特点：**  <br>
①接口可以创建引用指向实现类； <br>
②类‘继承’接口称之为实现接口，使用关键字implements； <br>
③一个类可以实现多个接口； <br>
④接口中方法默认修饰符public abstract； <br>
⑤接口中成员变量默认修饰符public abstract final； <br>
⑥接口与接口之间支持多继承，格式：`Interface 接口名1 extends接口名2, 接口名3, 接口名4{}`  <br>
接口是程序中不同模块之间达成的协议。 <br>
**接口优点：** 降低耦合度，提高代码复用性，提高程序扩展性。 <br>

## 17.内部类
当B类依赖A类的存在而存在时，把B类定义为A类的内部类。 <br>
内部类的分类： <br>
①成员内部类：作为外部类的一个成员存在，成员内部类不能定义静态变量 <br>
②局部内部类：在方法中定义的内部类，与局部变量类似 <br>
③静态内部类：用static定义内部类 <br>
④匿名内部类：匿名内部类是在抽象类和接口的基础之上发展起来的。匿名内部类如果继承自接口,必须实现指定接口的方法,且无参数 。匿名内部类如果继承自类,参数必须按父类的构造函数进行参数传递。 <br>
**匿名内部类的特点：**  <br>
①一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是覆盖。 <br>
②只是为了获得一个对象实例，不需要知道其实际类型。 <br>
③不需要使用类名。 <br>
Java通过内部类和接口，可以很好的实现多继承的效果。  <br>
